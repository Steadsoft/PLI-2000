{\rtf1\ansi\ansicpg1252\uc1\deff0\stshfdbch0\stshfloch0\stshfhich0\stshfbi0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f150\froman\fcharset238\fprq2 Times New Roman CE;}{\f151\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f153\froman\fcharset161\fprq2 Times New Roman Greek;}
{\f154\froman\fcharset162\fprq2 Times New Roman Tur;}{\f155\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f156\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f157\froman\fcharset186\fprq2 Times New Roman Baltic;}
{\f158\froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\f160\fswiss\fcharset238\fprq2 Arial CE;}{\f161\fswiss\fcharset204\fprq2 Arial Cyr;}{\f163\fswiss\fcharset161\fprq2 Arial Greek;}{\f164\fswiss\fcharset162\fprq2 Arial Tur;}
{\f165\fswiss\fcharset177\fprq2 Arial (Hebrew);}{\f166\fswiss\fcharset178\fprq2 Arial (Arabic);}{\f167\fswiss\fcharset186\fprq2 Arial Baltic;}{\f168\fswiss\fcharset163\fprq2 Arial (Vietnamese);}{\f170\fmodern\fcharset238\fprq1 Courier New CE;}
{\f171\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f173\fmodern\fcharset161\fprq1 Courier New Greek;}{\f174\fmodern\fcharset162\fprq1 Courier New Tur;}{\f175\fmodern\fcharset177\fprq1 Courier New (Hebrew);}
{\f176\fmodern\fcharset178\fprq1 Courier New (Arabic);}{\f177\fmodern\fcharset186\fprq1 Courier New Baltic;}{\f178\fmodern\fcharset163\fprq1 Courier New (Vietnamese);}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;
\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;
\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Normal;}{\*\cs10 \additive \ssemihidden 
Default Paragraph Font;}{\*\ts11\tsrowd\trftsWidthB3\trpaddl108\trpaddr108\trpaddfl3\trpaddft3\trpaddfb3\trpaddfr3\trcbpat1\trcfpat1\tscellwidthfts0\tsvertalt\tsbrdrt\tsbrdrl\tsbrdrb\tsbrdrr\tsbrdrdgl\tsbrdrdgr\tsbrdrh\tsbrdrv 
\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1024\langfe1024\cgrid\langnp1024\langfenp1024 \snext11 \ssemihidden Normal Table;}}{\*\rsidtbl \rsid3015211\rsid6358243\rsid7349690\rsid12065488\rsid13705098\rsid16405709}
{\*\generator Microsoft Word 10.0.4524;}{\info{\author hughg}{\operator hughg}{\creatim\yr2006\mo4\dy25\hr15\min28}{\revtim\yr2006\mo4\dy25\hr15\min55}{\version5}{\edmins27}{\nofpages7}{\nofwords3718}{\nofchars21193}
{\*\company American College of Physicians}{\nofcharsws24862}{\vern16475}}\widowctrl\ftnbj\aenddoc\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\hyphcaps0\horzdoc\dghspace120\dgvspace120\dghorigin1701\dgvorigin1984\dghshow0\dgvshow3
\jcompress\viewkind1\viewscale181\viewzk2\nolnhtadjtbl\rsidroot6358243 \fet0\sectd \linex0\sectdefaultcl\sftnbj {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl3
\pndec\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang {\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}
{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}\pard\plain 
\ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\b\f1\fs20\insrsid16405709 PL/I Compiler Architecture Notes
\par 
\par History
\par }{\f1\fs20\insrsid16405709 
\par The open-source PL/I compiler started life as an experiment that gradually grew in size and capabilities. In the beginning it was never envisaged that a true language compiler would be attempted and in
deed, many of the early experiments resulted in frequent rewriting and re}{\f1\fs20\insrsid13705098 -}{\f1\fs20\insrsid16405709 architecting as the project grew in scope.
\par 
\par In 1990 I was looking for a PL/I compiler for DOS, something that might enable to me exploit my own industry }{\f1\fs20\insrsid13705098 experience}{\f1\fs20\insrsid16405709  and possibly consi
der product development on the PC/DOS platform. I searched high and low and to my considerable surprise had difficulty finding anything suitable, there we some products available but they were }{\f1\fs20\insrsid13705098 either dated or}{
\f1\fs20\insrsid16405709  very feature limited or high-end, costly and unsuitable for RAD type work.
\par 
\par It was at this time that I began working w}{\f1\fs20\insrsid6358243 i}{\f1\fs20\insrsid16405709 
th C professionally and decided to explore C by writing snippets and test programs, this led to writing experimental lexical scanners and crude parsers, at this time I had no intentio
n of doing anything ambitious or serious, I simply wanted to study C by writing non-trivial code.
\par 
\par One day I was studying recursive descent parsers, using some excellent (if a little simplistic) books, when I suddenly "grasped it" and began to really under
stand the process, as this began to solidify in my mind, I became very focused and for the first time }{\f1\fs20\insrsid13705098 seriously}{\f1\fs20\insrsid16405709  wondered if a real compiler might in fact be possible!
\par 
\par I began to accumulate some more sophisticated books and in particular found these titles to be of immense benefit:
\par 
\par 1. BORNAT: Understanding and Writing Compilers (superb)
\par 2. 
\par 
\par The Bornat book in particular was very helpful because it revealed how one could actually generate code from a parse tree, although other books cover this well, Bornat's book made this extremely clear and his detailed and pragmatic }{
\f1\fs20\insrsid3015211 explanations}{\f1\fs20\insrsid16405709  }{\f1\fs20\insrsid3015211 were}{\f1\fs20\insrsid16405709  ideal for a working programmer, it was far more than the theory oriented }{\f1\fs20\insrsid3015211 explanations}{
\f1\fs20\insrsid16405709  all too common in many books.
\par 
\par I had worked for years with IBM PL/I and Stratus VOS PL/I and had a very good working knowledge of the language; the latter was closely related to the Multics compiler and I researched and unearthed numerous papers dating from the time of Multics}{
\f1\fs20\insrsid3015211 , in particular the paper by Fr}{\f1\fs20\insrsid16405709 e}{\f1\fs20\insrsid3015211 i}{\f1\fs20\insrsid16405709 burghouse "The Multics PL/I Compiler
" (http://www.multicians.org/pl1-raf.html) was fascinating and when combined with my understanding of the Stratus compiler, really enabled me to seriously understand the real issues that a real PL/I compiler must address, eventually I ordered the ANSI PL/
I language standard manual for the 1982 version, thus completing my collection of academic material and specifications.
\par 
\par The project was and is a hobby, and has oscillated between complete dormancy and busy, active progress over the years. Unless one is abl
e to work on something like this full-time, as part of ones job, then it is difficult to give it the attention it warrants and therefore I consider it unlikely that this project would ever reach the level of a commercial grade, stable, sophisticated compi
ler, and for this reason I am making it open-source in the hope that it can serve as the basis for a more serious effort.
\par 
\par The compiler reached a stage in which some subsets of PL/I could be compiled to a DOS }{\f1\fs20\insrsid3015211 .}{\f1\fs20\insrsid16405709 obj file and that file linked with a runtime mod
ule, this would then actually execute, it was able to call DOS graphics functions etc and was }{\f1\fs20\insrsid3015211 therefore}{\f1\fs20\insrsid16405709  a "real" compiler. }{\f1\fs20\insrsid3015211 This}{\f1\fs20\insrsid16405709 
 project was then shelved for some year until I decided to abandon the DOS obj code and create a more powerful }{\f1\fs20\insrsid3015211 Pentium}{\f1\fs20\insrsid16405709  code genera
tor and COFF object file API, the current status is that the code generator has just begun to be modified so that procedure entry/exit code is created as defined by the }{\f1\fs20\insrsid3015211 register}{\f1\fs20\insrsid16405709 
 usage document (see PLI Register Usage.doc), consequently things are very clos
e to being able to generate some initial real PL/I object files. One of the features in this compiler is a compile-time option that controls the ordering of argument pushing, this allows us to create a compiler that can generate code that can freely call 
Microsoft C code, and this enables us to create a runtime library in C.
\par 
\par }{\b\f1\fs20\insrsid16405709 Architecture
\par }{\f1\fs20\insrsid16405709 
\par The compilers architecture is loosely }{\f1\fs20\insrsid3015211 modeled}{\f1\fs20\insrsid16405709  on the Stratus compiler and attempts to follow the ANSI 1982 }{\f1\fs20\insrsid3015211 standard}{\f1\fs20\insrsid16405709 
, in particular the explicit phases of compilation are the same, }{\f1\fs20\insrsid3015211 and these}{\f1\fs20\insrsid16405709  in fact stem from the Multics work. The compiler is written entirely in C, C++ would have been a better choice, }{
\f1\fs20\insrsid3015211 a }{\f1\fs20\insrsid16405709 compiler has so many sophisticated abstractions that an OO language really would provide measurable }{\f1\fs20\insrsid3015211 advantages}{\f1\fs20\insrsid16405709 .
\par 
\par The compiler proceeds (depending upon specific command line arguments) through the following phases, each phase is invoked as a function call from pl1.c
\par 
\par 1. }{\f1\fs20\insrsid3015211 Initialization}{\f1\fs20\insrsid16405709  - PLI.C
\par This is basic stuff like verify the source file}{\f1\fs20\insrsid3015211  exists}{\f1\fs20\insrsid16405709 , delete any }{\f1\fs20\insrsid3015211 existing}{\f1\fs20\insrsid16405709  object and listing files and ensure that the compiler }{
\f1\fs20\insrsid3015211 error}{\f1\fs20\insrsid16405709  message file exists etc.
\par 
\par 2. Lexical Analysis/Parsing - SCANNER.C and PASS1.C
\par This phase is a hand-written recursive descent }{\f1\fs20\insrsid3015211 parser;}{\f1\fs20\insrsid16405709  it calls a lexical (tokenizing) function to obtain the next language t
oken (represented as a C structure). The tokenizer hides all file I/O and also handles the opening of include files, the parser does not "see" include files. No PL/I preprocessing is }{\f1\fs20\insrsid3015211 supported}{\f1\fs20\insrsid16405709 
 (and indeed is very limited anyway in the ANSI 1982 standard). As tokens are read, the large }{\f1\fs20\insrsid3015211 set of recursive functions verifies}{\f1\fs20\insrsid16405709  syntax}{\f1\fs20\insrsid3015211 ,}{\f1\fs20\insrsid16405709  and create}
{\f1\fs20\insrsid3015211 s}{\f1\fs20\insrsid16405709  and populate}{\f1\fs20\insrsid3015211 s}{\f1\fs20\insrsid16405709  parse tree node }{\f1\fs20\insrsid3015211 structures}{\f1\fs20\insrsid16405709 
. If a parsing function encounters a token that violates syntax, then this is reported (along with line number etc) and the }{\f1\fs20\insrsid3015211 parsing}{\f1\fs20\insrsid16405709  funct
ion then skips for ward to the next semicolon, thereby attempting some degree of continuation. As each parsing function proceeds it (usually) makes call to parse other language constructs as they are encountered, additionally the parser creates both refer
ence trees and expression trees as it encounters references of any type and expressions of any type. If the parser encounters explicit declarations, it verifies syntax etc and }{\f1\fs20\insrsid3015211 creates}{\f1\fs20\insrsid16405709 
 symbol nodes in a symbol tree that is attached to the procedure node for the current procedure block.
\par 
\par 3. Declaration Processing - DECLARE.C
\par This phase is called if the parsing phase did not encounter any fatal errors. The phase is concerned with }{\f1\fs20\insrsid3015211 validating}{\f1\fs20\insrsid16405709  every declared entity (including entry points etc). It calculates the s
ize and offsets of every name}{\f1\fs20\insrsid3015211  (for those names that have this known at compile time)}{\f1\fs20\insrsid16405709 
, including structures, arrays and combinations thereof. This phase also calculates alignment (although not completely implemented yet). The main goal here is to augment the symbol table so that the later code generator can rea
dily generate static or stack accessing instructions for data.
\par 
\par 
\par 4. Semantic Processing - PASS2.C
\par The phase is }{\f1\fs20\insrsid3015211 responsible}{\f1\fs20\insrsid16405709  for resolving every reference to a symbol table entry, if this cannot be done then it attempts to create a new symbol with default at
tributes, this corresponds to the well known PL/I feature of allowing names to be undeclared in some cases. At then end of this phase, EVERY reference (including those references present in EVERY expression) contains detailed meta-data relating to the dec
lared name that is accessed. This phase create and inserts "offset expression" trees too. These expressions represent runtime calculations that must be performed in order to access a }{\f1\fs20\insrsid3015211 datum;}{\f1\fs20\insrsid16405709 
 this is covered very elegantly in Freiburghouse's paper. The code g
enerator is able to elegantly process these expression in the same way it processes explicit user-coded expressions, however the code generator "knows" that these expressions ultimately represent address/offset calculation code. This phase also performs a
 large number of detailed }{\f1\fs20\insrsid3015211 checks}{\f1\fs20\insrsid16405709 
 for errors that are not syntactic. For example attempting to "call" a bin(15) variable or passing too few args to procedure, or "goto" a name that is not a label etc, if the source code "survives" this phase, it is in pretty 
good shape! Finally this phase detects where conversions are required and modifies the parse-tree accordingly. For example: A = B + C; (where A, B and C are some combination of decimal and binary) requires some operands (and sometimes the result expressio
n) to be converted, so the parse-tree that represents:
\par 
\par A = B + C;
\par 
\par may be modified by this phase to become:
\par 
\par A = conv_xxx_to_yyy ( conv_zzz_to_yyy (B) + C );
\par 
\par where xxx, etc represent types (eg conv_dec_to_bin etc). This is only implemented to a basic degree at this stage, but the architecture is sufficiently well progressed for this to be expanded. }{\f1\fs20\insrsid12065488 This phase must
 also scrutinize all references and report any ambiguous structure references. }{\f1\fs20\insrsid16405709 
Once this phase is complete, the parse-tree and the symbol-table contain everything that is needed for the code generator (or optionally optimizer) to begin the
 creation of instruction sequences which are ultimately "fed" to the object module management library.
\par 
\par 5. Allocation Phase
\par This phase walks the symbol table. In doing so it invokes COFF library functions in order to create the necessary meta-data describing static storage and }{\f1\fs20\insrsid3015211 initialized}{\f1\fs20\insrsid16405709 
 storage along with external names etc. This phase reflects the high level structure of a COFF object }{\f1\fs20\insrsid3015211 module;}{\f1\fs20\insrsid16405709  the latter is neatly }{\f1\fs20\insrsid3015211 abstracted}{\f1\fs20\insrsid16405709 
 through its own API (COFFLIB.C). After this phase is complete the COFF management 
layer contains all the data required for outputting static and constant data including strings etc, note that the COFF library is itself fairly powerful and builds an in-memory tree for the various COFF sections, these are only written to the OBJ file qui
te late in the code gen phase.
\par 
\par 6. Code Generator
\par The code }{\f1\fs20\insrsid7349690 generator}{\f1\fs20\insrsid16405709 
 walks the parse tree (and the symbol table) in a similar way to PASS2. As it encounters each kind of PL/I node it creates machine instructions sequences, often with calls to address gener
ating functions (that accept the offset expression trees discussed earlier). This phase is tied-in to the Pentium CPU although it does use a layer of abstraction to do this. In particular it populates "instruction nodes" that represent the source and targ
et registers, addressing modes etc and then passes these to a function: CpuGenerate( ); The instruction structure completely abstracts the Pentium, any instruction can be }{\f1\fs20\insrsid7349690 represented}{\f1\fs20\insrsid16405709  by the }{
\f1\fs20\insrsid7349690 appropriate}{\f1\fs20\insrsid16405709  setting of the structure fields. The CPU generation library (EMITTER.C) uses a fairly effective table driven machine to }{\f1\fs20\insrsid7349690 convert}{\f1\fs20\insrsid16405709 
 the abstract instruction structure into the specific machine bytes required by the instruction, this is a compact piece of code that refers to a set of tables, it is very effective and as I say, very compact, the tables (which is not fully }{
\f1\fs20\insrsid7349690 implemented}{\f1\fs20\insrsid16405709  yet}{\f1\fs20\insrsid7349690 , some instructions are not represented}{\f1\fs20\insrsid16405709 ) is found in: PENTIUM.H. Basically this code use}{\f1\fs20\insrsid7349690 s}{
\f1\fs20\insrsid16405709  the opcode, source addressing mode and target addressing mode to do a lookup into an array (in essence a 3D array) this lookup }{\f1\fs20\insrsid7349690 (after some secondary processing) }{\f1\fs20\insrsid16405709 returns
 the specific byte(s) needed for that instruction, this is }{\f1\fs20\insrsid7349690 now stable and }{\f1\fs20\insrsid16405709 fairly easy to debug/extend.
\par 
\par Once the code generator finishes, a COFF compliant object module will exist, this is then linkable using any WIN32 32-bit linker which should include runtime and other supporting libraries.
\par 
\par }{\b\f1\fs20\insrsid16405709 Internal Structures
\par }{\f1\fs20\insrsid16405709 
\par The compiler uses a large number of data structures, every one of these is defined as a typ}{\f1\fs20\insrsid7349690 e}{\f1\fs20\insrsid16405709 
def with a simple naming convention, in addition typedefs are defined that represent pointers to each structure types. These latter typedefs make it much easier to }{\f1\fs20\insrsid7349690 declare}{\f1\fs20\insrsid16405709 
 pointers and read complex code that that declares numerous kinds of pointers, the suffix "_ptr" is used }{\f1\fs20\insrsid7349690 extensively}{\f1\fs20\insrsid16405709  for this purpose.
\par 
\par The compiler create two trees as it progresses, these are the parse tree and the symbol table. These two trees are actually connected, but they are functionally different which is why I distinguish between them.
\par 
\par The root of the created parse tree is actually a node of type "Block", every PL/I block is represented by one of these nodes be it a procedure or begin block. Here is a Block node }{\f1\fs20\insrsid7349690 included here }{\f1\fs20\insrsid16405709 
for ease of reading:
\par 
\par }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 typedef}{\f2\fs16\insrsid16405709\charrsid7349690  }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 struct}{\f2\fs16\insrsid16405709\charrsid7349690  block_node \{
\par                }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690        type;
\par                }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 char}{\f2\fs16\insrsid16405709\charrsid7349690         line[10];       }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* line no, declared on            */}{
\f2\fs16\insrsid16405709\charrsid7349690  
\par                Block_ptr   parent;         }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* pointer to parent PL/1 block    */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                Block_ptr   child;          }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* pointer to 1st child block      */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                Block_ptr   sister;         }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* pointer to adjacent sister      */}{\f2\fs16\insrsid16405709\charrsid7349690   
\par                Any_ptr     first_stmt;     }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* 1st stmt node in this block     */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                Symbol_ptr  first_symbol;   }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* first declared name in block    */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                Data_ptr    ret_ptr;        }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* ie returns (char(32))           */}{\f2\fs16\insrsid16405709\charrsid7349690   
\par                }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 char}{\f2\fs16\insrsid16405709\charrsid7349690         block_name[32]; }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* ascii spelling of procname      */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690        depth;          }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* zero for
 outermost block        */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690        begin;          }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* True if this is a begin block   */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690        function;       }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* True if block is function       */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690        recursive;      }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* True if block is recu
rsive      */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690        main;           }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* Set if block is main entry      */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690        num_args;       }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* How many parameters             */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690        num_rets;       }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* No of returns stmts in block    */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690        called;         }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* Is the block referenced ?       */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 long}{\f2\fs16\insrsid16405709\charrsid7349690         stack;          }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* Size of stack frame             */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 long}{\f2\fs16\insrsid16405709\charrsid7349690         stattic;        }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* Size of static area             */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 long}{\f2\fs16\insrsid16405709\charrsid7349690         seg_pos;        }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* pos'n in file of SEGDEF         */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690        params;         }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* Size of stack for arg ptrs      */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690        data_idx;       }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* Section number of blocks static */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690        code_idx;       }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* Section number of blocks code   */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690        stack_idx;      }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* SEGMENT Index of blocks stack   */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690        sym_count;      }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* Number of names in this proc    */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                \} Block;
\par }{\f1\fs20\insrsid16405709 
\par A PL/I block can have a parent as well as child and sibling blocks. A block with several child blocks will point to the first child, and the other child blocks are linked using the "sister" pointer.
\par 
\par One of the jobs that the parser must do is c
orrectly populate this structure as and when new PL/I blocks are encountered, it must also thread them correctly. In addition to the various tree related pointers, there are two important pointers: "first_stmt" and "first_symbol". These point to a block's
 statement tree and its declaration tree (including names declared by implication). The }{\f1\fs20\insrsid7349690 statement}{\f1\fs20\insrsid16405709 
 tree is a tree that contains a node for every kind of PL/I language construct whilst the symbol tree contains a node for every declared (and undeclared if possible) name. The statement tree is a pointer of type "Any_ptr" which is just a typ}{
\f1\fs20\insrsid7349690 e}{\f1\fs20\insrsid16405709 def for void *. This is because the statement tree may contain any }{\f1\fs20\insrsid7349690 type}{\f1\fs20\insrsid16405709 
 of node, statement nodes are chained together (just as statements are sequentially listed in code) using the "stmt_ptr" found in almost every kind of node, here is a typical PL/I node:
\par 
\par }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 typedef}{\f2\fs16\insrsid16405709\charrsid7349690  }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 struct}{\f2\fs16\insrsid16405709\charrsid7349690  assignment_node \{
\par                }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690        type;
\par                }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 char}{\f2\fs16\insrsid16405709\charrsid7349690         line_no[10];
\par                Any_ptr     stmt_ptr;
\par                Ref_ptr     target;   }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* The a  in a = 3;  */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                Any_ptr     source;   }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* The 3  in a = 3;  */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 char}{\f2\fs16\insrsid16405709\charrsid7349690         by_name;  }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* Non zero if true  */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                \} Assignment;}{\f2\fs20\insrsid16405709\charrsid7349690 
\par }{\f1\fs20\insrsid16405709 
\par This node can represent ANY kind of PL/I assignment statement and as can
 be seen, it contains the field "stmt_ptr" which points to the node that represents the next statement in the original source code. This particular kind of node also contains a Ref_ptr which can represent ANY kind of PL/I variable reference, and an Any_pt
r that represents an expression tree. By the time code generation begins, every statement node is correctly and fully populated and all names references and expression trees are fully expanded and populated, the parser and semantic phase are }{
\f1\fs20\insrsid7349690 responsible}{\f1\fs20\insrsid16405709  for this, every possible type, attribute, default etc is set by these phases.
\par 
\par Every symbol is represented by the generic "Symbol" node, this node contains many quite obvious fields but also contains many other fields that are less obvious, these play a cruci
al role in later phases especially code generation. Here is the Symbol node structure:
\par 
\par }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 typedef}{\f2\fs16\insrsid16405709\charrsid7349690  }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 struct}{\f2\fs16\insrsid16405709\charrsid7349690  symbol_node \{
\par         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690          node_type;        }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* Allows pass2 to recognise symbols*/
\par }{\f2\fs16\insrsid16405709\charrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 char}{\f2\fs16\insrsid16405709\charrsid7349690           line[10];         }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* line no, declared on             */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 unsigned}{\f2\fs16\insrsid16405709\charrsid7349690       bad_dcl:       1; }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* syntax error in declaration      */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 unsigned}{\f2\fs16\insrsid16405709\charrsid7349690       known_size:    1; }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* size is determinable by compiler */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         Bit           varying:       1; }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* varying string                   */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 unsigned}{\f2\fs16\insrsid16405709\charrsid7349690       variable:      1; }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* entry, label etc.                */}{\f2\fs16\insrsid16405709\charrsid7349690  
\par         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 unsigned}{\f2\fs16\insrsid16405709\charrsid7349690       known_locn:    1; }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* locn is determinable by compiler */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 unsigned}{\f2\fs16\insrsid16405709\charrsid7349690       structure:     1; }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* 0 = scalar, 1 = structure/member */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 unsigned}{\f2\fs16\insrsid16405709\charrsid7349690       keyword:       1; }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* set to true if possible keyword  */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 unsigned}{\f2\fs16\insrsid16405709\charrsid7349690       qualified:     1; }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* is name a '.' name ?             */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 unsigned}{\f2\fs16\insrsid16405709\charrsid7349690       declared:      1; }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* appeared in a dcl statement      */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 unsigned}{\f2\fs16\insrsid16405709\charrsid7349690       computational: 1; }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* as defined in ANSI document      */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 unsigned}{\f2\fs16\insrsid16405709\charrsid7349690       vola_tile:     1; }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* for concurrent O/S.              */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 unsigned}{\f2\fs16\insrsid16405709\charrsid7349690       referenced:    1; }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* is this symbol actually used ?   */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 unsigned}{\f2\fs16\insrsid16405709\charrsid7349690       asterisk:      1; }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* is the sym a char(*) parameter ? */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 unsigned}{\f2\fs16\insrsid16405709\charrsid7349690       temporary:     1; }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* this is a compiler created temp  */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 unsigned}{\f2\fs16\insrsid16405709\charrsid7349690       aligned:       1; }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* alignment given when declared ?  */
\par }{\f2\fs16\cf2\insrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 unsigned}{\f2\fs16\insrsid7349690       }{\f2\fs16\insrsid16405709\charrsid7349690 initial:       1; }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* did 'init' appear
 on declare ?   */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 unsigned}{\f2\fs16\insrsid16405709\charrsid7349690       file:          1; }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* is symbola a file ?              */}{\f2\fs16\insrsid16405709\charrsid7349690  
\par         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690          ext_code_idx;     }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* If extrnl, the idx of the EXTDEF */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690          ext_static_idx;   }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* If extrnl, the idx of the EXTDEF */
\par }{\f2\fs16\cf2\insrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690          cons_idx;         }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* Index of .rdata section, if applicable */

\par }{\f2\fs16\cf2\insrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 long}{\f2\fs16\insrsid16405709\charrsid7349690           coff_symtab_idx;  }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* Index in COFF symbol table.      */
\par }{\f2\fs16\cf2\insrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 long}{\f2\fs16\insrsid16405709\charrsid7349690           coff_strtab_idx;  }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* Index in COFF string table.      */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690          level;            }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* structure level of this name     */
\par }{\f2\fs16\insrsid16405709\charrsid7349690      }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /*short          value_reg;           Is this syms val in register ?   */
\par }{\f2\fs16\insrsid16405709\charrsid7349690      }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /*short          locn_reg;            Is the syms offset in a reg ?    */}{\f2\fs16\insrsid16405709\charrsid7349690  
\par         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 long}{\f2\fs16\insrsid16405709\charrsid7349690           bytes;            }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* required storage in bytes        */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 long}{\f2\fs16\insrsid16405709\charrsid7349690           size;             }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* if an array, the element size    */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690          prec_1;           }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* The a in  fixed dec (a,b)        */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690          prec_2;           }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* The b in  fixed 
dec (a,b)        */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 long}{\f2\fs16\insrsid16405709\charrsid7349690           offset;           }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* offset in stack/static           */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690          token;            }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* token id                         */}{\f2\fs16\insrsid16405709\charrsid7349690  
\par         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690          }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 class}{\f2\fs16\insrsid16405709\charrsid7349690 ;            }{
\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* based, static, defined, auto     */}{\f2\fs16\insrsid16405709\charrsid7349690  
\par         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690          type;             }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* char, numeric, pointer, pic      */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690          scope;            }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* internal or external             */}{\f2\fs16\insrsid16405709\charrsid7349690    
\par         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690          scale;            }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* fixed or float                   */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690          num_dims;         }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* number of declared dims/args     */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 char}{\f2\fs16\insrsid16405709\charrsid7349690          *pic_text;         }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* ptr to pic specification text    */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 char}{\f2\fs16\insrsid16405709\charrsid7349690          *spelling;         }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* ascii spelling of name         
  */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         Ref_ptr       defbas_ptr;       }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* Ref that symbol is based/def on  */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         Block_ptr     declarator;       }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* PL/1 block in which declared     */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         Block_ptr     proc_ptr;         }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* ptr to block if internal proc    */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         Any_ptr       array_ptr;        }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* first array-bound/arg descriptor */
\par }{\f2\fs16\insrsid7349690         Init_ptr      }{\f2\fs16\insrsid16405709\charrsid7349690 init_ptr;}{\f2\fs16\insrsid7349690          }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* ptr to initial descriptor        */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         Data_ptr      ret_ptr;          }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* ptr to returns descriptor if any */}{\f2\fs16\insrsid16405709\charrsid7349690 \tab 
\par         Symbol_ptr    parent;           }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* structure parent if applicable   */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         Symbol_ptr    child;            }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* ptr to 1st structure member      */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         Symbol_ptr    sister;           }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* ptr to next field at this level  */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         Symbol_ptr    prev_ptr;         }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* previous symbol in list          */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         Symbol_ptr    next_ptr;         }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* next symbol in list              */
\par }{\f2\fs16\insrsid16405709\charrsid7349690         \} Symbol;}{\f2\fs20\insrsid16405709 
\par 
\par }{\f1\fs20\insrsid16405709 As can be seen a symbol node contains pointers to a Block node if the name is in fact an internal procedure, the Block node contains all blo
ck specific metadata in this case. The field "defbas_ptr" requires a little explanation; this is a pointer that is only populated if a name is declared as defined or based, and it points to a reference tree that represents the entity upon which this name 
i
s defined or based. Rememeber that a symbol node represents a single name and in the case of a structure there is a symbol for every level as well as fields within a level. The symbol node structure can represent ANY PL/I declaration that is its purpose; 
if names are encouneterd that are not declared, then (language rules permitting) symbol nodes are created and populated as-if the name WAS declared (the flag "declared" however, can be examined to see if a name was or was not explicitly declared).
\par 
\par It is absolutely vital that one understands the meaning of the term "reference" in PL/I else considerable confusion can arise. A PL/I refernce is an expression that refers to an address in memory. These are expressions:
\par }{\f2\fs20\insrsid16405709\charrsid7349690 
\par }\pard \ql \fi720\li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0\pararsid16405709 {\f2\fs16\cf2\insrsid16405709\charrsid7349690 subject.name
\par counters(I)
\par master(I).today.max
\par }\pard \ql \li720\ri0\nowidctlpar\faauto\rin0\lin720\itap0\pararsid16405709 {\f2\fs16\cf2\insrsid16405709\charrsid7349690 tree_root->table.control_field
\par }\pard \ql \fi720\li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0\pararsid16405709 {\f2\fs16\cf2\insrsid16405709\charrsid7349690 table(X,Y,count_ptr->counts.subentity(control.category_code))}{\f2\fs20\cf2\insrsid16405709\charrsid7349690 
\par }\pard \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 {\f2\fs20\cf2\insrsid16405709 
\par 
\par }{\f1\fs20\insrsid16405709 
\par and so on.
\par 
\par As can be seen, a reference may }{\f1\fs20\insrsid16405709 contain}{\f1\fs20\insrsid16405709  expressions (the array subscripts) as well
 as dot and ptr references. The node "Ref" is designed to allow ANY PL/I reference to be represented completely, here is the node:
\par 
\par }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 typedef}{\f2\fs16\insrsid16405709\charrsid7349690  }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 struct}{\f2\fs16\insrsid16405709\charrsid7349690  ref_node \{
\par                }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690        type;
\par                }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690        num_subs;    }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* No of subscripts                 */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690        data_type;   }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* type of this entire ref          */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690        scale;       }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* scale (if any) of entire ref     */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 short}{\f2\fs16\insrsid16405709\charrsid7349690        null_list;   }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* Does this ref have a () ?        */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                }{\f2\fs16\cf2\insrsid16405709\charrsid7349690 char}{\f2\fs16\insrsid16405709\charrsid7349690         *spelling;   }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 
/* The lexical text of this ref node*/
\par }{\f2\fs16\insrsid16405709\charrsid7349690                Symbol_ptr  symbol;      }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* The resolved symbol for this ref */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                Symbol_ptr  attribs;     }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* A symbol node for attributes only*/}{\f2\fs16\insrsid16405709\charrsid7349690  
\par                Symbol_ptr  temp;        }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* A temporary for conversion use   */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                Sub_ptr     sublist;     }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* Ptr to subscript list            */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                Ref_ptr     dot_ptr;     }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* Ptr to next ref if qualified     */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                Ref_ptr     ptr_ptr;     }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* Ptr to next ref if a   ->   ref  */
\par }{\f2\fs16\insrsid16405709\charrsid7349690                Any_ptr     ofx_ptr;     }{\f2\fs16\cf11\insrsid16405709\charrsid7349690 /* Ptr to offset expression         */}{\f2\fs16\insrsid16405709\charrsid7349690  
\par                \} Ref;}{\f1\fs16\insrsid16405709\charrsid7349690 
\par }{\f1\fs20\insrsid16405709 
\par 
\par This node records all data associated with a }{\f1\fs20\insrsid16405709 reference}{\f1\fs20\insrsid16405709 
 and allows other references nodes to be referred to by the dot_ptr or ptr_ptr. The PL/I reference subject.name would be represented by a Ref node that links to the Symbol node for "subject" it would als
o have its "dot_ptr" member pointing to another Ref node, this one pointing to the "name" Symbol. It is instructive to run PL/I code through the compiler that declares various structures and arrays and then assigns to fields within them, if you compile th
i
s with the +dump_nodes option, you will see a detailed dump of the parse tree (including ref nodes). It will be appreciated that even a reference like the last one listed above, will result in a pretty complicated reference tree! Because of the foregoing,
 it must be appreciated that NO PL/I statements refer simply to symbols, they ALWAYS refers to Ref nodes, even if a reference is a simple name.
\par 
\par Finally you will see the field "ofx_ptr" this is a pointer to the variables offset expression a vitally importan
t concept in PL/I compilers. The compiler creates expression trees called "offset expressions" which it creates and inserts into Ref nodes. Thes}{\f1\fs20\insrsid16405709 e}{\f1\fs20\insrsid16405709  }{\f1\fs20\insrsid16405709 expressions}{
\f1\fs20\insrsid16405709  represent runtime calculations that must be performed to fully identify the address that is to be re
ferenced by the code. A simple example is an array reference, the compiler deduces the nature of the reference and determines an expression that is based upon array dimensions, subscript values}{\f1\fs20\insrsid16405709 , alignment}{
\f1\fs20\insrsid16405709  etc and embeds the expression tree into the reference.
\par 
\par The code generator sees this expression tree (if present) and generates runtime code that will perform the computation required to fully determine the address. This is very well explained in the Freiburghouse paper. 
\par 
\par 
\par 
\par 
\par 
\par }}