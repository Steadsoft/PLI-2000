/****************************************************************************/
/*                           COPYRIGHT NOTICE                               */
/****************************************************************************/
/* A PL/I Compiler for the Win32 platform.                                  */
/* Copyright (C) 1997 - 2006 Hugh Gleaves.                                    */
/*                                                                          */
/* This program is free software; you can redistribute it and/or            */
/* modify it under the terms of the GNU General Public License              */
/* as published by the Free Software Foundation; either version 2           */
/*                                                                          */
/* This program is distributed in the hope that it will be useful,          */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of           */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
/* GNU General Public License for more details.                             */
/*                                                                          */
/* You should have received a copy of the GNU General Public License        */
/* along with this program; if not, write to the Free Software              */
/* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 */
/* USA.                                                                     */
/****************************************************************************/

/****************************************************************************/
/*                         Modification History                             */
/****************************************************************************/
/*  Who    When                           What                              */
/* ------------------------------------------------------------------------ */
/* HWG    13-07-90       Initial Prototype.                                 */
/* HWG    03-08-90       Improve input record buffering                     */
/* HWG    10-10-90       Code to create .lst file, inserted.                */
/* HWG    03-01-91       Include File Expansion Implemented.                */
/* HWG    15-05-91       Page headings etc added to make list look nicer.   */
/* HWG    15-07-91       %replace processing implemented.                   */
/* HWG    01-08-91       A major re-org has taken place in the compiler     */
/*                       it is based on the method used by the Multics      */
/*                       compiler, in that all lexeme strings are held on   */
/*                       a singly linked list. The tokens returned to the   */
/*                       caller (pass1) do NOT now contain the lexeme, but  */
/*                       rather a POINTER to an entry in the lexeme-list.   */
/* HWG    15-09-91       Comments may now be nested, this was done to allow */                                               
/*                       large sections of code to be commented out for     */
/*                       testing purposes.                                  */
/* HWG    16-09-91       The compiler headings are now printed prior to the */
/*                       source file being opened.                          */
/* HWG    22-09-91       New %list and %nolist directives installed.        */
/* HWG    30-09-91       %page incorporated.                                */
/*                                                                          */
/* HWG    04-01-92       String literals that were greater than 32 chars    */
/*                       were causing 'insert' to screw-up. This function   */
/*                       has now been fixed.                                */   
/* HWG    12-07-92       The mapcase option now translates all upper case   */
/*                       items to lower case (except in strings !)          */
/****************************************************************************/

/****************************************************************************/
/*                         Functional Description                           */
/****************************************************************************/
/* This file contains the functions needed to open the source file, and     */
/* begin lexical analysis. The output listing file is generated by code in  */
/* here too.                                                                */
/* The scanner is called by the parser (pass1) each time it wants a new     */
/* token. The scanner then accumulates single characters from a buffer      */
/* (filled by a line of PL/1 source) until a recognized token is built.     */
/* The lexeme (if applicable) is then added to a lexeme list, and the token */
/* has a pointer set to this.                                               */
/* The directive %replace is handled as well, and each token that could be  */
/* defined via this, is searched for down the list, with its appropriate    */
/* replace value returned instead.                                          */
/* Parts of the scanner module are a little messy, cos this was one of the  */
/* first things written for the compiler.                                   */
/****************************************************************************/

# include <stdio.h>
# include <string.h>
# include <stdlib.h>
# include <ctype.h>
# include <time.h>
# include "c_types.h"
# include "tokens.h"
# include "token.h"
# include "extrnals.h"
# include "release.h"
# include "nodes.h"
# include "pointers.h"
# include "lex.h"

# define _LINE_     ((short)__LINE__)


# define  ERROR_1               1
# define  MAX_SYMBOLS           146 /* size of the keyword array */
# define  SYMLENGTH             15
# define  TABCHAR               '\t'
# define  CR                    '\r'
# define  NL                    '\n'
# define  FF                    '\f'
# define  BTAB                  '\b'
# define  SPACE                 ' '
# define  EOS                   '\x00'     /* End Of String */
# define  EOL                   '\x0A'     /* End Of Line   */          
# define  BUFFRSIZE             1024       /* 250 */
# define  A                     0
# define  B                     1
# define  OLD                   0
# define  NEW                   1
# define  MAX_INCLS             9   /* ie 10   !   */
# define  MAX_IDENT_LEN         64
       
extern FILE  *LISTING;
extern short nesting;
extern short nesting_reqd;
extern short mapcase_reqd;
extern short listing_reqd;
extern short code_reqd;
extern short optimize_reqd;
extern short beep_reqd;
extern short table_reqd;
extern unsigned long symtab_heap_used;
extern char stats[25][256];
extern char * _pgmptr;

char raw_name[1024];
char srcfile[1024];

/***************************************************************************/
/*             Structures used for %replace list processing.               */
/***************************************************************************/

typedef struct rep_st  *Rep_ptr;

typedef struct rep_st {
        char          rep_name[33];
        char          rep_value[256];
        short           token;
        short           keyword;
        void         *next_ptr;
        } Rep_item;

/***************************************************************************/
/*                This array hold all PL/I keywords and the like.          */
/***************************************************************************/

static char kwrd[MAX_SYMBOLS][SYMLENGTH] =
           {"procedure",
            "declare",
            "options",
            "do",
            "end",
            ";",
            ":",
            "begin",
            "on",
            "binary",
            "decimal",
            "defined",
            "based",
            "static",
            "fixed",
            "float",
            "(",
            ")",
            "-",
            "+",
            "*",
            "/",
            "pointer",
            "/*",
            "*/",
            "character",
            "entry",
            "to",
            "=",
            "if",
            "then",
            "else",
            ".",
            "call",
            "goto",
            "while",
            "return",
            "bit",
            "varying",
            "variable",
            "^",
            ">",
            "<",
            "&",
            "|",
            "||",
            ">=",
            "<=",
            "^=",
            "->",
            "picture",
            "by",
            "like",
            "aligned",
            "addr",
            "allocate",
            "set",
            "returns",
            "recursive",
            "stop",
            "free",
            "otherwise",
            "select",
            "when",
            ",",
            "%",
            "automatic",
            "internal",
            "external",
            "condition",
            "unaligned",
            "builtin",
            "put",
            "skip",
            "list",
            "leave",
            "conversion",
            "fixedoverflow",
            "overflow",
            "size",
            "underflow",
            "zerodivide",
            "beginpage",
            "endfile",
            "endpage",
            "key",
            "record",
            "transmit",
            "undefinedfile",
            "area",
            "error",
            "finish",
            "storage",
            "all",
            "any",
            "until",
            "volatile",
            "%include",
            "%replace",
            "%list",
            "%nolist",
            "%page",
            "main",
            "stack",
            "file",
            "signal",
            "go",
            "name",
            "initial",
            "^>",
            "^<",
            "^>=",
            "^<=",
            "open",
            "close",
            "read",
            "write",
            "environment",
            "stream",
            "input",
            "output",
            "update",
            "sequential",
            "direct",
            "print",
            "nonprint",
            "keyed",
            "title",
            "linesize",
            "pagesize",
            "loop",
            "repeat",
            "rewrite",
            "delete",
            "into",
            "keyto",
            "sizeto",
            "from",
            "keyfrom",
            "get",
            "edit",
            "tab",
            "line",
            "column",
            "string",
            "page"};

/***************************************************************************/
/*                 This array holds all PL/I abbreviations etc.            */
/***************************************************************************/

static char abrv[MAX_SYMBOLS][SYMLENGTH] =
           {"proc",
            "dcl",
            "options",
            "do",
            "end",
            ";",
            ":",
            "begin",
            "on",
            "bin",
            "dec",
            "def",
            "based",
            "static",
            "fixed",
            "float",
            "(",
            ")",
            "-",
            "+",
            "*",
            "/",
            "ptr",
            "/*",
            "*/",
            "char",
            "entry",
            "to",
            "=",
            "if",
            "then",
            "else",
            ".",
            "call",
            "goto",
            "while",
            "return",
            "bit",
            "var",
            "variable",
            "^",
            ">",
            "<",
            "&",
            "|",
            "||",
            ">=",
            "<=",
            "^=",
            "->",
            "pic",
            "by",
            "like",
            "aligned",
            "addr",
            "alloc",
            "set",
            "returns",
            "recursive",
            "stop",
            "free",
            "other",
            "select",
            "when",
            ",",  
            "%",
            "auto",
            "internal",
            "ext",
            "cond",
            "unal",
            "builtin",
            "put",
            "skip",
            "list",
            "leave",
            "conv",
            "fofl",
            "ofl",
            "size",
            "ufl",
            "zdiv",
            "beginpage",
            "endfile",
            "endpage",
            "key",
            "record",
            "transmit",
            "undf",
            "area",
            "error",
            "finish",
            "storage",
            "all",
            "any",
            "until",
            "volatile",
            "%include",
            "%replace",
            "%list",
            "%nolist",
            "%page",
            "main",
            "stack",
            "file",
            "signal",
            "go",
            "name",
            "init",
            "^>",
            "^<",
            "^>=",
            "^<=",
            "open",
            "close",
            "read",
            "write",
            "env",
            "stream",
            "input",
            "output",
            "update",
            "sequential",
            "direct",
            "print",
            "nonprint",
            "keyed",
            "title",
            "linesize",
            "pagesize",
            "loop",
            "repeat",
            "rewrite",
            "delete",
            "into",
            "keyto",
            "sizeto",
            "from",
            "keyfrom",
            "get",
            "edit",
            "tab",
            "line",
            "col",
            "string",
            "page"};

Lex_ptr  lexeme_root_ptr   = NULL;
short    status            = 0;
long     max_pos           = 0; /* max position in source stream so far */
short    last_symbol       = (MAX_SYMBOLS);  /* these are important ! */
short    first_user_symbol = (MAX_SYMBOLS+1);  /* see also MAX_SYMBOLS  */
static short    within_a_comment  = 0;   /* set if lexical analyser in a comment */
short    save;
short    backtrack         = 0;
long     curr_rec          = 0;
long     save_rec          = 0;
long     lines_printed     = 0;
long     pages_printed     = 1;

/***************************************************************************/
/* These declares are all connected with File input and include processing */
/***************************************************************************/

long     total_lines ;
long     total_stmts ;
long     line_number [MAX_INCLS];
short    incl_number [MAX_INCLS];
long     index       [MAX_INCLS];
char     record      [MAX_INCLS][BUFFRSIZE];
long     reclen      [MAX_INCLS];
char     *rec_ptr    [MAX_INCLS];
FILE     *in_port    [MAX_INCLS];
short    incl_count      = 0;
char     line_no[10]     = "";     
unsigned long bytes_read = 0;
char     fixed [1024];
short    depth           = 0;

Rep_ptr rep_root     = NULL;
Rep_ptr last_rep_ptr = NULL;

/***************************************************************************/
/*                         Function definitions.                           */
/***************************************************************************/ 

static char_ptr  locate_lexeme     (char_ptr);
static Rep_ptr   find_replace      (char_ptr);
void      initialise        (char_ptr);
Token_ptr get_token         (void);
short     seperator         (short);
static Token     insert            (char_ptr);
static short     bgetc             (void);
short     devoid            (char_ptr);
void      report            (short,char_ptr,short);
static void      print_line_info   (void);
void      check_print       (short);
static void      define_replace    (char_ptr,char_ptr,short,short);
void      get_exe_dir       (char_ptr);
Rep_ptr   find_replace      (char_ptr);
static short plitext        (int);
 
/***************************************************************************/
/*                    S T A R T    O F    C O D E                          */
/***************************************************************************/

void 

   initialise (char_ptr filename)

   {

   short I;

   status = 0;

/*   if (strlen(filename) > 12) */ /* if user typed crap, then.... */
/*      filename[12] = 0x0;     */

   /***********************************************************/
   /*        Print copyright message and headings etc.        */
   /***********************************************************/ 

   strupr(filename);

   sprintf (stats[0],"\n\nCOPYRIGHT Hugh Gleaves 2006\n");
   sprintf (stats[1],"COMPILATION STATISTICS FOR PL/I Release %d.%d.%d.%s %s\n",
           RMAJ,
           RMIN,
		   RREV, 
		   STAGE,
           filename);                
   sprintf (stats[2],"\nPHASE          MSECS      ERRORS    WARNINGS        DISK\n");

   printf(stats[0]);
   printf(stats[1]);
   printf(stats[2]);


   /*****************************************************************/
   /*                  Open the pl1 source file !                   */
   /*****************************************************************/

   in_port[depth] = fopen (filename,"r");

   if (in_port[depth] == NULL)
      {
      report(16,filename,_LINE_);
      exit(0);
      }

   strcpy(srcfile,filename);

   strcpy (fixed,srcfile);

   fixed[strlen(fixed)] = ' '; /* overwrite the 00 with a space */
   fixed[32] = 0x00;           /* and stick it on the end !     */
                                                               
   /***************************************************************/
   /*        Setup the I/O buffer initialisation values           */
   /***************************************************************/

   for (I=0; I < MAX_INCLS; I++)
       {
       index[I]       = 1;
       reclen[I]      = 0;
       rec_ptr[I]     = &record[I][0];
       record[I][0]   = EOL; 
       line_number[I] = 0;
       incl_number[I] = 0;
       }

   curr_rec      = A;
   save_rec      = A;
   total_lines   = 0;

   }

/**************************************************************************/
/* Find the DOS 'dir' from which the compiler EXE was loaded by DOS.      */
/**************************************************************************/

void  /* this func is redundant on NT */

   get_exe_dir (char * dir_ptr)

   {

   char           *temp_ptr;
   short          *two_nulls_ptr;

   temp_ptr = getenv("PATH");

   if (temp_ptr == NULL)
      {
      printf("Fatal, unable to locate the 'PATH' environment string\n");
      printf("compilation terminated.\n\n");
      exit(0);
      }

   /***********************************************************************/
   /* OK we know that the 'dir_ptr' point 'inside' the env block for this */
   /* EXE, so lets search forward thru memory, looking for '0000' hex.    */
   /***********************************************************************/

   two_nulls_ptr = (short *)temp_ptr;

   while (*two_nulls_ptr != 0)
         {
         temp_ptr++;
         two_nulls_ptr = (short *)temp_ptr;
         }

   /**********************************************************************/
   /* Now the ptr points to the two null field just before the start of  */
   /* the pathname.                                                      */
   /**********************************************************************/

   temp_ptr++; temp_ptr++;
   temp_ptr++; temp_ptr++;

   strcpy(dir_ptr,_pgmptr); /* VC++ */

   /**********************************************************************/
   /* Now we must examine the string backwards to strip off the filename */
   /* we overwrite the last '\' with a null to do this.                  */
   /**********************************************************************/

   temp_ptr = dir_ptr + strlen(dir_ptr);

   while ((*temp_ptr != '\\') & (*temp_ptr != ':'))
         temp_ptr--;

   *temp_ptr = '\x00';

   }


/**************************************************************************/
/* Determine and return the next token from the input stream              */
/**************************************************************************/

Token_ptr 

   get_token ()

     {

     short      car;
     short      state = 1; /* start state */
     char       buffer[1024];
     short      idx;
     short      comment_depth = 0;
     static     Token      token;  /* MUST be static ! */
     Rep_item   rep_data;
     Rep_ptr    r_ptr;
     char       inc_file[33];

     /******************************************************************/
     /* This function is a finite state automaton, it performs lexical */
     /* analysis of the PL/1 source file, and returns PL/1 tokens.     */
     /******************************************************************/

     memset(buffer,EOS,126);

     token.lexeme = NULL;

     while (1)
           {

           if (backtrack)
              {
              car = save;
              backtrack = 0;
              }
           else
              car = bgetc();

           if ((car == EOF) || (car == '\26')) 
              {
              token.token = END_OF_SOURCE;
              token.keyword = 0;
              /**********************************************************/
              /* If we have EOF and we are still inside a comment, then */
              /* issue a special diagnostic.                            */
              /**********************************************************/
              if (within_a_comment)
                 report(-137,"",_LINE_);
              return (&token);
              }
  
           /****************************************************************/
           /* OK Process the character just read, in accrodance with our   */
           /* current state.                                               */
           /******************************************************************/
    
           switch (state) {

           case(1):
               buffer[0] = '\0';
               idx       = 0;
               if (seperator(car))
                  break;
   
               if ((isalpha(car)) || (car == '_') || (car == '$'))
                  {
                  state = 21;
                  buffer[idx] = (char)car;
                  idx++;
                  break;
                  }
               if (car == '\'')
                  {
                  buffer[idx] = (char)car;
                  idx++;
                  state = 45;
                  break;
                  }
               if (car == '.')
                  {
                  token = insert(".");
                  token.keyword = 0;
                  return(&token);
                  }
               if (car == '%')
                  {
                  buffer[idx] = (char)car;
                  idx++;
                  state = 50;
                  break;
                  }
               if (car == ',')
                  {
                  token = insert(",");
                  token.keyword = 0;
                  return(&token);
                  }
               if (car == ':')
                  {
                  token = insert(":");
                  token.keyword = 0;
                   return(&token);
                  }
               if (car == ';')
                  {
				  total_stmts++;
                  token = insert(";");
                  token.keyword = 0;
                  return(&token);
                  }     
               if (car == '&')
                  {
                  token = insert("&");
                  token.keyword = 0;
                  return(&token);
                  }
               if (car == '-')
                  {
                  buffer[idx] = (char)car;
                  idx++;
                  state = 10;
                  break;
                  }
               if (car == '+')
                  {
                  token = insert("+");
                  token.keyword = 0;
                  return(&token);
                  }
               if (car == '*')
                  {
                  token = insert("*");
                  token.keyword = 0;
                  return(&token);
                  }
               if (car == '/')
                  {
                  buffer[idx] = (char)car;
                  idx++;
                  state = 22;
                  break;
                  }
               if (car == '(')
                  {
                  token = insert("(");
                  token.keyword = 0;
                  return(&token);
                  }
               if (car == ')')
                  {
                  token = insert(")");
                  token.keyword = 0;
                  return(&token);
                  }
               if (car == '=')
                  {
                  token = insert("=");
                  token.keyword = 0;
                  return(&token);
                  } 
               if (car == '>')
                  {
                  buffer[idx] = (char)car;
                  idx++;
                  state = 5;
                  break;
                  }
               if (car == '|')
                  {
                  buffer[idx] = (char)car;
                  idx++;
                  state = 7;
                  break;
                  } 
               if ((car == '^') || (car == 'ª'))
                  {
                  buffer[idx] = (char)car;
                  idx++;
                  state = 6;
                  break;
                  }
               if (car == '<')
                  {
                  buffer[idx] = (char)car;
                  idx++;
                  state = 8;
                  break;
                  }
               if (isdigit(car))
                  {
                  buffer[idx] = (char)car;
                  idx++;
                  state = 15;
                  break;
                  }
               token.token = BAD_TOKEN;
               token.keyword = 0;
               buffer[0] = (char)car;
               buffer[1] = EOS;
               report (78,buffer,_LINE_);
               return(&token);
           case(5):
               if (seperator(car))
                  {
                  token = insert(">");
                  token.keyword = 0;
                  return(&token);
                  }
               if (car == '=')
                  {
                  token = insert(">=");
                  token.keyword = 0; 
                  return(&token);
                  }

               save = car;
               backtrack = 1;
               token.token = BAD_TOKEN;
               token.keyword = 0;
               buffer[idx] = (char)car;
               idx++;
               report (78,buffer,_LINE_);
               return(&token);
           case(6):
               if (seperator(car))
                  {
                  token = insert("^");
                  token.keyword = 0;
                  return(&token);
                  }
               if (car == '=')
                  {
                  token = insert("^=");
                  token.keyword = 0; 
                  return(&token);
                  }
               if (car == '>')
                  {
				  buffer[idx] = (char)car;
				  idx++;
				  state = 11;
                  break;
                  }
               if (car == '<')
                  {
                  buffer[idx] = (char)car;
                  idx++;
				  state = 12;
				  break;
                  }
			   if (plitext(car))
                  {
				  save = car;
				  backtrack = 1;
                  token = insert("^");
				  token.keyword = 0;
                  return(&token);
                  }
          
               save = car;
               backtrack = 1;
               token.token = BAD_TOKEN;
               token.keyword = 0;
               buffer[idx] = (char)car;
               idx++;
               report (78,buffer,_LINE_);
               return(&token);
		   case(11):
		       if (seperator(car))
		          {
		          token = insert("^>");
		          token.keyword = 0;
		          return(&token);
		          } 
		       if (car == '=')
			      {
				  token = insert("^>="); /* NOTGE */
				  token.keyword = 0;
				  return(&token);
				  }
			   if (plitext(car))
			      {
				  save = car;
				  backtrack = 1;
				  token = insert("^>");
				  token.keyword = 0;
				  return(&token);
				  }

               save = car;
               backtrack = 1;
               token.token = BAD_TOKEN;
               token.keyword = 0;
               buffer[idx] = (char)car;
               idx++;
               report (78,buffer,_LINE_);
               return(&token);
		   case(12):
		       if (seperator(car))
		          {
		          token = insert("^<");
		          token.keyword = 0;
		          return(&token);
		          } 
		       if (car == '=')
			      {
				  token = insert("^<="); /* NOTGE */
				  token.keyword = 0;
				  return(&token);
				  }
			   if (plitext(car))
			      {
				  save = car;
				  backtrack = 1;
				  token = insert("^<");
				  token.keyword = 0;
				  return(&token);
				  }
		 
		       save = car;
               backtrack = 1;
               token.token = BAD_TOKEN;
               token.keyword = 0;
               buffer[idx] = (char)car;
               idx++;
               report (78,buffer,_LINE_);
               return(&token);
           case(7):
               if (car == '|')
                  {
                  token = insert("||");
                  token.keyword = 0;
                  return(&token);
                  }
               save = car;
               backtrack = 1;
               token = insert("|");
               token.keyword = 0;
               return(&token);
           case(8):
               if (seperator(car))
                  {
                  token = insert("<");
                  token.keyword = 0;
                  return(&token);
                  }
               if (car == '=')
                  {
                  token = insert("<=");
                  token.keyword = 0;
                  return(&token);
                  }
               save = car;
               backtrack = 1;
               token.token = BAD_TOKEN;
               token.keyword = 0;
               buffer[idx] = (char)car;
               idx++;
               report (78,buffer,_LINE_);
               return(&token);
           case(10):
               if (car == '>')
                  {
                  token = insert("->");
                  token.keyword = 0;
                  return(&token);
                  }
               save = car;
               backtrack = 1;
               token = insert("-");
               token.keyword = 0;
               return(&token);
           case(15):
               if (car == '.')
                  {
                  buffer[idx] = (char)car;
                  idx++;
                  state = 16;
                  break;
                  }   
               if ((car == 'e') || (car == 'E'))                
                  {
                  buffer[idx] = 'E';
                  idx++;
                  state = 17;
                  break ;
                  }        
               if (isdigit(car))
                  {
                  buffer[idx] = (char)car;
                  idx++;
                  break;
                  }
               state = 1;
               buffer[idx] = EOS;
               token = insert(buffer);
               save = car;
               backtrack = 1;
               token.token = NUMERIC;
               token.keyword = 0;
               return(&token);
           case(16):
               if (isdigit(car))
                  {
                  buffer[idx] = (char)car;
                  idx++;
                  break;
                  }
               if ((car == 'e') || (car == 'E'))                
                  {
                  buffer[idx] = 'E';
                  idx++;
                  state = 17;
                  break ;
                   }        
               save = car;
               backtrack = 1;
               buffer[idx] = EOS;
               token = insert(buffer);
               token.token = NUMERIC;
               token.keyword = 0;
               return(&token);
           case(17):
               if ((car == '-') || (car == '+'))
                  {
                  buffer[idx] = (char)car;
                  idx++;
                  state = 18;
                  break;
                  }
               if (isdigit(car))
                  {
                  buffer[idx] = (char)car;
                  idx++;
                  break;
                  }
               save = car;
               backtrack = 1;
               buffer[idx] = EOS;
               token = insert(buffer);
               token.token = NUMERIC;
               token.keyword = 0;
               return(&token);
           case(18):
               if (isdigit(car))
                  {
                  buffer[idx] = (char)car;
                  idx++;
                  break;
                  }
               save = car;
               backtrack = 1;
               buffer[idx] = EOS;
               token = insert(buffer);
               token.token = NUMERIC;
               token.keyword = 0;
               return(&token);
           case(21):
               if ((isalnum(car)) || (car == '_') || (car == '$'))
                  {
                  buffer[idx] = (char)car;
                  idx++;
                  break;
                  }
               buffer[idx] = EOS;
               if (strlen(buffer) > MAX_IDENT_LEN)
                  {
                  buffer[MAX_IDENT_LEN] = EOS;
                  report(-82,buffer,_LINE_);
                  }       
               token = insert(buffer);
               save = car;
               backtrack = 1;
               r_ptr = find_replace(buffer);
               if (r_ptr != NULL)
                  {
                  token.token   = r_ptr->token;
                  token.keyword = r_ptr->keyword;
                  token.lexeme  = r_ptr->rep_value;
                  return(&token);
                  }
               if (token.token < first_user_symbol)
                  {
                  token.keyword = 1;
                  return(&token);
                  }
               else
                  {
                  token.token = PL1NAME;
                  token.keyword = 0;
                  return(&token);
                  }
           case(22):
               if (car == '*')
                  {
                  state = 30;
                  within_a_comment = 1;
                  comment_depth++;
                  break;
                  }
               if (comment_depth != 0)
                  {
                  state = 30;
                  break;
                  }
               save = car;
               backtrack = 1;
               token = insert("/");
               token.keyword = 0;
               return(&token);
           case(30):
               if ((car == '*'))
                  {
                  state = 31;
                  break;
                  }
               if (car == '/') /* start of a nested comment ? */
                  state = 22; 
               break;
           case(31):
               if ((car == '/') && (comment_depth == 1))
                  {
                  state = 1;
                  within_a_comment = 0;
                  comment_depth--;
                  break;
                  }
               if (car == '/')
                  {
                  comment_depth--;
                  state = 30;
                  break;
                  }
               state = 30;
               save = car;
               backtrack = 1;
               break;
           case(45):
               if (car == '\'') /* ie a single ' character */
                  {
                  buffer[idx] = (char)car;
                  idx++;
                  buffer[idx] = EOS;
                  state = 46; 
                  break;
                  }
               buffer[idx] = (char)car;
               idx++;
               break;
           case(46):   /* is it a bit or char string ? */
               {
               token = insert(buffer);
               if (car == 'b')
                  token.token = BIT_STRING;
               else
                  {
                  save = car;
                  backtrack = 1;
                  token.token = STRING;
                  /* we must strip off the quotes */
                  token.lexeme += 1; /* move 1 char forward */
                  token.lexeme[strlen(token.lexeme)-1] = '\x00'; /* set last ' to 0 */
                  }
               return(&token);
               }
           case(50): /* a % stmt has begun */
               if (seperator(car))
                  break;
               if (isalpha(car))
                  {
                  buffer[idx] = (char)car;
                  idx++;
                  state = 51;
                  break;
                  }
               else
                  {
                  token.token = BAD_TOKEN;
                  token.keyword = 0;
                  buffer[idx] = (char)car;
                  idx++;
                  report (78,buffer,_LINE_);
                  return(&token);
                  }
           case(51):
               if (isalpha(car))
                  {
                  buffer[idx] = (char)car;
                  idx++;
                  break;
                  }
               if ((car != ' ') && (car != ';'))
                  {
                  token.token = BAD_TOKEN;
                  token.keyword = 0;
                  buffer[idx] = (char)car;
                  idx++;
                  report (78,buffer,_LINE_);
                  return(&token);
                  }
               /******************************************************/
               /* OK At this point the buffer contains the following */
               /* %characters   We must scan the table to see if it  */
               /* is a recognised preprocessor statement.            */
               /******************************************************/ 
               token = insert(buffer);
               if (token.token == PCNT_INCLUDE)
                  {
                  state = 57;
                  break;
                  }
               if (token.token == PCNT_REPLACE)
                  {
                  state = 70;
                  idx = 0;
                  break;
                  }
               if (token.token == PCNT_LIST)
                  {
                  state = 1;
                  /*********************************************************/
                  /* Only enable listing if it was originally selected by  */
                  /* the user via the cmd line, ie if the file is opened.  */
                  /*********************************************************/
                  if (LISTING != NULL)
                     listing_reqd = 1;
                  break;
                  }
               if (token.token == PCNT_NOLIST)
                  {
                  state = 1;
                  listing_reqd = 0;
                  break;
                  }
               if (token.token == PCNT_PAGE)
                  {
                  state = 1;
               if (listing_reqd)
                  {
                  pages_printed++;
                  fprintf (LISTING,"\fWindows NT 32-bit PL/I Optimizing Compiler, File Name: %s                Page %3ld\n\n",fixed,pages_printed);
                  lines_printed = 2;
                  }
               break;
               }
               report (106,buffer,_LINE_); /* was 78 */
               state = 1;
               break;
           case(57):
               if (seperator(car))
                  break;
               if (car == '\'')
                  state = 58;
               else
                  {
                  token.token = BAD_TOKEN;
                  token.keyword = 0;
                  buffer[idx] = (char)car;
                  idx++;
                  report (78,buffer,_LINE_);
                  return(&token);
                  }
               break;
           case(58):
               if (isalpha(car) || (car == '_'))
                  {
                  idx = 0;
                  buffer[idx] = (char)car;
                  idx++;
                  state = 59;
                  break;
                  }
               token.token = BAD_TOKEN;
               token.keyword = 0;
               buffer[idx] = (char)car;
               idx++;
               report (78,buffer,_LINE_);
               return(&token);
           case(59):
               if ((isalnum(car)) || (car == '_'))
                  {
                  buffer[idx] = (char)car;
                  idx++;
                  break;
                  }
                  buffer[idx] = EOS;
                  token = insert(buffer);
                  save = car;
                  backtrack = 1;
                  /******************************************/
                  /* The name of the file to be included is */
                  /* now put into the token entity.         */
                  /******************************************/
                  token.token = PL1NAME;
                  token.keyword = 0;
                  state = 60;
                  break;
           case(60):
               if (car == '\'')
                  {
                  state = 61;
                  break;
                  }
               token.token = BAD_TOKEN;
               token.keyword = 0;
               buffer[idx] = (char)car;
               idx++;
               report (78,buffer,_LINE_);
               return(&token);
           case(61):
               if (seperator(car)) break;
               if (car == ';')
                  {
                  /*****************************************/
                  /* OK DO the Bizz with this include file */
                  /*****************************************/
                  depth++;

                  if (depth > MAX_INCLS)
                     {
                     report(180,"",_LINE_);
                     exit(0);
                     }

                  incl_count++;
                  incl_number[depth] = incl_count;
                  line_number[depth] = 0;
                  index[depth]   = 1;
                  reclen[depth]  = 0;
                  rec_ptr[depth] = &record[depth][0];
                  record[depth][0] = EOL; 
                  /****************************************************/
                  /*     Verify that the suffix is specified !        */
                  /****************************************************/
                  strcpy (inc_file,token.lexeme);
                  strrev (inc_file);

                  if (inc_file[3] != '.') 
                     {
                     strrev (inc_file);
                     strcat (inc_file,".inc");
                     }
                  else
                     strrev (inc_file);
             
                  in_port[depth] = fopen (inc_file,"r");
                  if (in_port[depth] == NULL)
                     {
                     report(47,inc_file,_LINE_);
                     exit(0);
                     }
                  state = 1;
                  break;
                  }
               token.token = BAD_TOKEN;
               token.keyword = 0;
               return(&token);
           case(70):
               if (car == ' ') break;
               if ((isalpha(car)) || (car == '_') || (car == '$'))
                  {
                  state = 71;
                  buffer[idx] = (char)car;
                  idx++;
                  break;
                  }
           case(71):
               if ((isalnum(car)) || (car == '_') || (car == '$'))
                  {
                  buffer[idx] = (char)car;
                  idx++;
                  break;
                  }
               buffer[idx] = EOS;
               if (strlen(buffer) > 32)
                  {
                  buffer[32] = EOS;
                  report(-82,buffer,_LINE_);
                  } 
               /*************************************************************/
               /* OK Put the replace 'name' into the rep_data structure. We */
               /* must now, look for the keyword 'by'.                      */
               /*************************************************************/      
               save = car;
               backtrack = 1;
               strcpy(rep_data.rep_name,buffer);
               state = 72;
               break;
           case(72):
               {
               if (seperator(car)) break;
               if (car != 'b')
                  {
                  report (78,buffer,_LINE_);
                  return(&token);
                  }
               state = 73;
               break;
               } 
           case(73):
               {
               if (car != 'y')
                  {
                  report (78,buffer,_LINE_);
                  return(&token);
                  }
               state = 74;
               break;
               }
           case(74): /* acquire synonym definition */
               {
               if (seperator(car)) break;
               if (isalpha(car) || (car == '_') || (car == '$'))
                  {
                  idx = 0;
                  buffer[idx] = (char)car;
                  idx++; 
                  state = 75;
                  break;
                  }
               if (isdigit(car))
                  {
                  idx = 0;
                  buffer[idx] = (char)car;
                  idx++;
                  state = 76;
                  break;
                  }
               if (car == '\'')
                  {
                  idx = 0;
                  buffer[idx] = (char)car;
                  idx++;
                  state = 80;  /* 45;   */
                  break;
                  }
               buffer[0] = (char)car;
               buffer[1] = EOS;  
               report(78,buffer,_LINE_);
               return(&token);
           case(75):    
               if ((isalnum(car)) || (car == '_') || (car == '$'))
                  {
                  buffer[idx] = (char)car;
                  idx++;
                  break;
                  }
               buffer[idx] = EOS;
               if (strlen(buffer) > 32)
                  {
                  buffer[32] = EOS;
                  report(-82,buffer,_LINE_);
                  }       
               token = insert(buffer);
               save = car;
               backtrack = 1;
               if (token.token < first_user_symbol)
                  {
                  rep_data.token = token.token;
                  rep_data.keyword = 1;
                  }
               else
                  {
                  rep_data.token = PL1NAME;
                  rep_data.keyword = 0;
                  }
               /************************************************************/
               /* Insert this new replace-definition into the replace list */
               /************************************************************/
               strcpy(rep_data.rep_value,buffer);
               define_replace (rep_data.rep_name,
                               rep_data.rep_value,
                               rep_data.token,
                               rep_data.keyword);
               state = 1;
               break;
               } 
           case(76):
               if (car == '.')
                  {
                  buffer[idx] = (char)car;
                  idx++;
                  state = 77; /* 16; */   /* This is a fixed dec constant */
                  break;
                  }   
               if ((car == 'e') || (car == 'E'))                
                  {
                  buffer[idx] = 'E';
                  idx++;
                  state = 78;  /* 17; */
                  break ;
                  }        
               if (isdigit(car))
                  {
                  buffer[idx] = (char)car;
                  idx++;
                  break;
                  }
               state = 1;
               buffer[idx] = EOS;
               token = insert(buffer);
               save = car;
               backtrack = 1;
               rep_data.token = NUMERIC;
               rep_data.keyword = 0;
               /************************************************************/
               /* Insert this new replace-definition into the replace list */
               /************************************************************/
               strcpy(rep_data.rep_value,buffer);
               define_replace (rep_data.rep_name,
                               rep_data.rep_value,
                               rep_data.token,
                               rep_data.keyword);
               state = 1;
               break;
           case(77):
               if (isdigit(car))
                  {
                  buffer[idx] = (char)car;
                  idx++;
                  break;
                  }
               if ((car == 'e') || (car == 'E'))                
                  {
                  buffer[idx] = 'E';
                  idx++;
                  state = 78; /* 17; */
                  break ;
                  }        
               save = car;
               backtrack = 1;
               buffer[idx] = EOS;
               token = insert(buffer);
               rep_data.token = NUMERIC;
               rep_data.keyword = 0;
               strcpy(rep_data.rep_value,buffer);
               define_replace (rep_data.rep_name,
                               rep_data.rep_value,
                               rep_data.token,
                               rep_data.keyword);
               state = 1;
               break;
           case(78):
               if ((car == '-') || (car == '+'))
                  {
                  buffer[idx] = (char)car;
                  idx++;
                  state = 79; /* 18; */
                  break;
                  }
               if (isdigit(car))
                  {
                  buffer[idx] = (char)car;
                  idx++;
                  break;
                  }
               save = car;
               backtrack = 1;
               buffer[idx] = EOS;
               token = insert(buffer);
               rep_data.token = NUMERIC;
               rep_data.keyword = 0;
               strcpy(rep_data.rep_value,buffer);
               define_replace (rep_data.rep_name,
                               rep_data.rep_value,
                               rep_data.token,
                               rep_data.keyword);
               state = 1;
               break;
           case(79):
               if (isdigit(car))
                  {
                  buffer[idx] = (char)car;
                  idx++;
                  break;
                  }
               save = car;
               backtrack = 1;
               buffer[idx] = EOS;
               insert(buffer);
               rep_data.token = NUMERIC;
               rep_data.keyword = 0;
               strcpy(rep_data.rep_value,buffer);
               define_replace (rep_data.rep_name,
                               rep_data.rep_value,
                               rep_data.token,
                               rep_data.keyword);
               state = 1;
               break;
           case(80):
               if (car == '\'') /* ie a single ' character */
                  {
                  buffer[idx] = (char)car;
                  idx++;
                  buffer[idx] = EOS;
                  state = 81; /* 46; */
                  break;
                  }
               buffer[idx] = (char)car;
               idx++;
               break;
           case(81):   /* is it a bit or char string ? */
               {
               if (car == 'b')
                  rep_data.token = BIT_STRING;
               else
                  {
                  save = car;
                  backtrack = 1;
                  rep_data.token = STRING;
                  }
               token = insert(buffer);

               if (rep_data.token == STRING)  /* strip quotes */
                  {
                  token.lexeme += 1; /* move 1 char forward */
                  token.lexeme[strlen(token.lexeme)-1] = '\x00'; /* set last ' to 0 */
                  strcpy(buffer,token.lexeme);
                  }

               rep_data.keyword = 0;
               strcpy(rep_data.rep_value,buffer);
               define_replace (rep_data.rep_name,
                               rep_data.rep_value,
                               rep_data.token,
                               rep_data.keyword);
               state = 1;
               break;
               }
           /************************************************************/
           /* If we get to this default clause, were in big trouble !  */
           /************************************************************/
           default:
               report (56,token.lexeme,_LINE_);  /* Undefined state in lexer */
               break;

           } /* switch */

           } /* while */

    
     } /* get_token  */


/**************************************************************************/
/* Is the supplied parameter simply an inconsequential format character ? */
/**************************************************************************/

short seperator(short c)


    {

    if (c == TABCHAR || c == SPACE || c == CR ||
        c == EOL || c == FF    || c == BTAB ||
        c == EOS || c > 127)
        return(1);

    return(0);

    }

/****************************************************************************/
/* This function scans thru a list of strucs, looking for the supplied text */
/* If found the ptr to the text is returned, else a new struc is chained    */
/* onto the list, and a ptr to its text is returned.                        */
/****************************************************************************/

static char *locate_lexeme (char * lexeme)

     {

     Lex_ptr   item_ptr;
     Lex_ptr   last_ptr; 
     size_t    s1;
     size_t    s2; 
     
     item_ptr = lexeme_root_ptr;

     while (item_ptr != NULL)
           {
           if (item_ptr->text_ptr[0] == lexeme[0]) /* only bother with strcmp, if 1st chars are same */
              if (strcmp(item_ptr->text_ptr,lexeme) == 0)
                 return (item_ptr->text_ptr);

           last_ptr = item_ptr;
           item_ptr = last_ptr->next_ptr;
           }

     /******************************************************************/
     /* We did not find an ocurrence of the text, so create a new item */
     /******************************************************************/
                           
     s1 = sizeof(Lex);
     s2 = strlen(lexeme) + 1;
          
     item_ptr           = (Lex_ptr) malloc (s1);
     item_ptr->text_ptr = (char_ptr)  malloc (s2);
     item_ptr->next_ptr = NULL;

     symtab_heap_used += s2;
     symtab_heap_used += s1;;

     strcpy(item_ptr->text_ptr,lexeme);

     if (lexeme_root_ptr == NULL)
        lexeme_root_ptr = item_ptr;
     else
        last_ptr->next_ptr = item_ptr;
     
     return (item_ptr->text_ptr);

     }

/**************************************************************************/
/* Insert a new lexeme into the lexeme-list, we first search the fixed    */
/* array of keywords (and abbreviations) to see if the lexeme is a keyword*/
/* should it not be, then 'locate_lexeme' is called, which searches the   */
/* lexeme-list, for the string, if not found it is appended to the list.  */
/**************************************************************************/

static Token 

   insert (char * name)



   {      
   
   Token     tt;
   short     I;
   char      text[256] = "";

   /*****************************************************************/
   /* If this lexeme DOESNT begin with a ' char then see if it must */
   /* be case-mapped .                                              */
   /*****************************************************************/

   if (name[0] != '\'') 
      if (mapcase_reqd)
         strlwr(name);

   /*****************************************************************/
   /* This used to be a simple array scanner, but was much too slow */
   /*****************************************************************/

   tt.token   = 0;
   tt.lexeme  = NULL;
   tt.keyword = 0;

   if (strlen(name) > 256)
      goto dont_bother;

   strcpy (text,name);

   for (I=0; I <= last_symbol; I++)
       {
       /****************************************************************/
       /* Only if the first two chars of the lexeme is the same as the */
       /* first two chars of the abbrev/keyword, do we compare fully.  */
       /* Profiling has shown that this has a signficant effect on the */
       /* CPU usage for such searching.                                */
       /****************************************************************/ 
       if ((text[0] == abrv[I][0]) && (text[1] == abrv[I][1]))
          if ((strcmp(abrv[I],text)) == 0) 
             {
             tt.keyword = 1;
             tt.token   = I;
             tt.lexeme  = &(abrv[I][0]);
             return(tt);
             }
 
       if ((text[0] == kwrd[I][0]) && (text[1] == kwrd[I][1]))
          if ((strcmp(kwrd[I],text)) == 0)
             {
             tt.keyword = 1;
             tt.token   = I;
             tt.lexeme = &(kwrd[I][0]);
             return(tt);
             }
       }

dont_bother:

   tt.lexeme = locate_lexeme (name);
   tt.token  = first_user_symbol;

   return (tt);

   }

/**************************************************************************/
/* This function will return the 'next' character to the caller.          */
/**************************************************************************/

static short bgetc (void)

    {

    short     temp;


step_back:

    if (index[depth] > reclen[depth])
       {
       /****************************************************************/
       /* Read a new buffer from the source file.                      */
       /****************************************************************/     

       if (fgets (rec_ptr[depth], BUFFRSIZE, in_port[depth]) == NULL)
          if (depth > 0)
             {
             fclose(in_port[depth]);
             depth--;
             goto step_back;
             }
          else
             return (EOF);
 
       line_number[depth]++;   
       total_lines++;
       print_line_info();
 

       /********************************************************/
       /*     If this is an empty line, then keep reading !    */
       /********************************************************/

       while (devoid(record[depth]))
             {
             if (fgets (rec_ptr[depth], BUFFRSIZE, in_port[depth]) == NULL)
                if (depth > 0)
                   {
                   fclose(in_port[depth]);                
                   depth--;
                   goto step_back;
                   }
                else
                   return (EOF);

             line_number[depth]++;
             total_lines++;
             print_line_info();
               
             } 
             
       reclen[depth] = strlen(record[depth]);
       bytes_read    += reclen[depth];
       index[depth]  = 0;  /* 1st char of new line */
       }
       /***************************************************************/
       /* OK Simply return the next character in the current buffer   */
       /***************************************************************/
       temp = (short)record[depth][index[depth]];
       index[depth]++;
       return (temp);

    } /* end of bgetc */

/***************************************************************************/
/*     This function will return true if the line is all white-spaces.     */
/***************************************************************************/

short devoid (char line[])

    {

    size_t  len;
    char   *spaces = "\x0A\x00\x20";

    len = strlen(line);

    
    if (len == strspn(line,spaces))
       return(1);    
    
    return (0);

    }
  
/***************************************************************************/
/* This function will correctly format the line number etc for the listing */
/***************************************************************************/

static void 

   print_line_info (void)

   {

   char  temp [10];
   short   length;

   if (depth > 0)
      {
      ltoa (incl_number[depth],line_no,10);
      strcat (line_no,"-");
      ltoa (line_number[depth],temp,10);
      strcat (line_no,temp);
      }
   else 
      ltoa (line_number[depth],line_no,10);


   length = strlen(line_no);

   length = 10 - length;

   if (within_a_comment)
      {
      memset (temp,' ',1);
      memset (&temp[1],'*',1);
      memset (&temp[2],' ',length-2);
      }
   else
      memset (temp,' ',length);
   
   temp[length-1] = '\0';

   strcat (temp,line_no);

   strcpy (line_no,temp);

   if (listing_reqd)
      {
      fprintf (LISTING,"%s ",line_no);
      if (nesting_reqd)
         fprintf (LISTING,"%3d ",nesting);
      fprintf    (LISTING," ");
      fprintf (LISTING,"%s",rec_ptr[depth]);
      check_print(1);
      }

   }

/***************************************************************************/
/*        Keep track of lines printed in the listing file so far.          */
/***************************************************************************/

void 

   check_print (short number)

   {

   lines_printed += number;

   if (lines_printed > 5600)
      {
      pages_printed++;
      fprintf (LISTING,"\nWindows NT 32-bit PL/I Optimizing Compiler, File Name: %s                Page %3ld\n\n",fixed,pages_printed);
      lines_printed = 2;
      }

   }

/**************************************************************************/
/*    Return an integer that indicates the priority of a PL/1 operator.   */
/**************************************************************************/

short priority (Any_ptr ptr)

    {

    Oper_ptr      o_ptr;

    if (ptr == NULL)
       return(0);

    o_ptr = ptr;

    switch (o_ptr->type) {
    case(OR):
        return(1);
    case(AND):
        return(2);
    case(GT):
    case(LT):
    case(GE):
    case(LE):
    case(NOTEQUAL):
    case(EQUALS):
        return(3);
    case(CONCAT):
        return(4);
    case(PLUS):
    case(MINUS):
        return(5);
    case(TIMES):
    case(DIVIDE):
        return(6);
    default:
        return(0);
    }

    }

/***************************************************************************/
/* Return a type code indicating the actual condition-type of the token.   */
/***************************************************************************/

short condition_type (short token)

    {

    switch(token) {
    case(BEGINPAGE):
    case(ENDFILE):
    case(ENDPAGE):
    case(KEY):
    case(RECORD):
    case(TRANSMIT):
    case(UNDEFINEDFILE):
        return(IO_CONDITION);
    case(CONVERSION):
    case(FIXEDOVERFLOW):
    case(OVER_FLOW):
    case(SIZE):
    case(UNDER_FLOW):
    case(ZERODIVIDE):
        return(COMP_CONDITION);
    case(AREA):
    case(ERROR):
    case(FINISH):
    case(STORAGE):
        return(OTHER_CONDITION);
    case(CONDITION):
        return(USER_CONDITION);
    default:
        return(0);

    }

    } 


/***************************************************************************/
/* Set default compiler options from what is found in the DOS environment  */
/***************************************************************************/

void 

   set_defaults (void)

   {
                      
   char *		env_ptr;
   
   env_ptr = getenv("PL1_NESTING");                      
                      
   if (env_ptr != NULL)
      if (strcmp(env_ptr,"1") == 0)
         nesting_reqd = 1;

    env_ptr = getenv("PL1_LIST");                      
                      
    if (env_ptr != NULL)
       if (strcmp(env_ptr,"1") == 0)
          listing_reqd = 1;
          
    env_ptr = getenv("PL1_CODE");                      
                      
    if (env_ptr != NULL)
       if (strcmp(env_ptr,"1") == 0)
          code_reqd = 1;
          
    env_ptr = getenv("PL1_OPTIMIZE");                      
                      
    if (env_ptr != NULL)
       if (strcmp(env_ptr,"1") == 0)
          optimize_reqd = 1;
          
    env_ptr = getenv("PL1_BEEP");                      
                      
    if (env_ptr != NULL)
       if (strcmp(env_ptr,"1") == 0)
          beep_reqd = 1;
          
    env_ptr = getenv("PL1_TABLE");                      
                      
    if (env_ptr != NULL)
       if (strcmp(env_ptr,"1") == 0)
          table_reqd = 1;


   }





/***************************************************************************/
/* This function takes, a replace definition, and installs it in the       */
/* replacement list.                                                       */
/***************************************************************************/

static void 

   define_replace (char_ptr replace_name,
                   char_ptr replace_value,
                   short replace_token,
                   short replace_keyword)


   {

   Rep_ptr      rep_node;

   if (find_replace(replace_name) != NULL)
      {
      report(102,replace_name,_LINE_); /* duplicate replace ignored */
      return;
      }

   rep_node = malloc(sizeof(Rep_item));

   strcpy (rep_node->rep_name,replace_name);
   strcpy (rep_node->rep_value,replace_value);
   rep_node->token = replace_token;
   rep_node->keyword = replace_keyword;
   rep_node->next_ptr = NULL;

   if (last_rep_ptr == NULL)
      {
      rep_root = rep_node;
      last_rep_ptr = rep_root;
      return;
      }
   else
      {
      last_rep_ptr->next_ptr = rep_node;
      last_rep_ptr = rep_node;
      return;
      }

   }

/***************************************************************************/
/* This function returns a pointer to the replace node, indicated by the   */
/* parameter 'replace_name'.                                               */
/***************************************************************************/

static Rep_ptr 

   find_replace (char_ptr replace_name)

  
   {

   Rep_ptr   temp_ptr;

   temp_ptr = rep_root;

   if (mapcase_reqd)
      strlwr(replace_name);

   while (temp_ptr != NULL)
         {
         if (temp_ptr->rep_name[0] == replace_name[0])
            if (strcmp(temp_ptr->rep_name,replace_name) == 0)
               return(temp_ptr);
         temp_ptr = temp_ptr->next_ptr;
         }

   return(NULL);

   }


/*******************************************************************************/
/* Returns TRUE of character is a legal PLI char, that can represent the start */
/* of an identifer, numeric constant or string constant.					   */
/*******************************************************************************/

short
static

plitext (int car)

{

if (isalnum(car) || (car == '_') || (car == '$') || (car == '\''))
   return(1);

return(0);

}
            
